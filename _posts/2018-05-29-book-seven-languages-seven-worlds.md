---
layout: post
title: "『7 つの言語 7 つの世界』読了"
date: 2018-05-29 00:00:00 +09:00
tags: book
image: /images/profile.png
---

『[7 つの言語 7 つの世界](https://www.ohmsha.co.jp/book/9784274068577/)』の読書メモです。

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">『7 つの言語 7 つの世界』を読み始めた <a href="https://t.co/KwVLBDq1v8">https://t.co/KwVLBDq1v8</a> <a href="https://twitter.com/hashtag/nhbk?src=hash&amp;ref_src=twsrc%5Etfw">#nhbk</a></p>&mdash; nhiroki (@nhiroki_) <a href="https://twitter.com/nhiroki_/status/996003002832977920?ref_src=twsrc%5Etfw">2018年5月14日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

# 読み始めた動機

- 色々な言語の並行並列処理機構に興味があるので、それをサーベイする前段階として各言語の特徴を押さえておきたい。
- 買ってから四年半も積んでるのでそろそろ消化したいという気持ちも・・・

# 読書メモ

ランダムな順番で読んだので、読書メモもランダムな順番。

- 第 6 章「Erlang」
  - アクターモデルによる並行処理、軽量なプロセスによるプロセス生成の低コスト化、状態と副作用の排除による並行性の管理の簡便化、クラッシュさせろ、死活監視、など。
  - 気になったことをざっくり。パターンマッチングによる関数呼び出しのサンプルを見て、関数オーバロードに似てるなと思った。メッセージのディスパッチにパターンマッチを使うのはとても良さそうに見える。
  - 軽量プロセスの実装が気になった。プラットフォームのプロセス・スレッドとのマッピングはどのようになっている？リンクの機能が掴みきれなかったので調べたい。軽量プロセスのネーミングサービスはどうなってる？ライブラリはどのようなプロセス管理の仕組みを提供している？
  - 読みながら、C-like なシンタックスに自分の思考が強く縛られていることがよく分かる。
- 第 3 章「Io」
  - プロトタイプベースの言語。メッセージ式を使ってメソッドを呼び出す。あらゆるものがオブジェクトで、スロットという key/value の仕組みを持つ。文法は必要最小限。その分ライブラリが大きいらしい？演算子を優先順位を指定して追加できるのが面白い
  - 並行性プリミティブはコルーチン、アクター、フューチャー。コルーチンはメッセージの呼び出し方で実現。@付きメッセージは別スレッドで実行され、@@付きの場合は常に自分のスレッドで実行される？要確認。メッセージ式が基本なので、自然にアクターへと拡張できるというのはなるほどという感じ。
  - どういう性質だろう？本文中では特に言及されてなかった気がする "Ioには，シングルスレッドの実行速度を低下させるような性質が数多く存在することを指摘しておかなければならない．"
- 第 5 章「Scala」
  - Scala は全体的にとても使いやすそうに見える。静的型付けで Ruby っぽい記法。Java の資産を活かせるし、関数型パラダイムをサポートしてる。XML が組み込みでサポートされてるのはびっくりした。
  - 並行処理については、アクターとキューによってサポートされてる。あとは Java のスレッドや並列コレクションも使える。アクターはスレッドプール内で起動。Actor オブジェクトを作らなくても actor { ... } でブロックをスレッドプール内実行できるのは便利そう。
  - self を一時変数に入れてキャプチャーしてメッセージの返送先にするのはなるほどと思った。メッセージ式の書き方やメッセージをパターンマッチングで振り分けるのは Erlang と同じ。
- 第 7 章「Clojure」
  - JVM で動く Lisp 方言。並行処理プリミティブは可変データを包んだ ref, atom, agent と、dosync 関数による STM。ref は STM 内でのみ変更可。トランザクションが不要なら atom を使う。agent は変更を別スレッドで非同期に行う。別スレッドでの処理には future を使う。
  - もちろん thread をそのまま使うこともできる。本書を読む限りだと、agent はデータだけを持つアクターっぽいなと思った。記法も agent に対して send を送る感じだし。
  - 可変データを特別な型で表現することで、それがトランザクション内でのみ変更されることを保証するってのはなるほどと思った。たとえトランザクションの機能があっても、可変データがトランザクション外で変更されたら意味ないし。
  - 一般的にロックはそういう保証がないのがつらい。最近は、例えば clang だとアノテーションを付けることでコンパイル時にチェックしてくれたりもするけど、付け忘れたらどうしようもない。

<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja"><p lang="ja" dir="ltr">一般的にロックはそういう保証がないのがつらい。最近は、例えば clang だとアノテーションを付けることでコンパイル時にチェックしてくれたりもするけど、付け忘れたらどうしようもない <a href="https://t.co/7GsadXZoud">https://t.co/7GsadXZoud</a> <a href="https://twitter.com/hashtag/nhbk?src=hash&amp;ref_src=twsrc%5Etfw">#nhbk</a></p>&mdash; nhiroki (@nhiroki_) <a href="https://twitter.com/nhiroki_/status/999419042497638400?ref_src=twsrc%5Etfw">2018年5月23日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

- 第 8 章「Haskell」
  - 本書は各言語ごとに三日間かけるという構成になってて、今まで読んだ章は三日目は並行処理に関する話だったんだけど、本章の三日目はモナドに関する話で並行処理については言及がなかった。残念。
- 第 1 章「はじめに」
  - 本書の狙いや扱う言語の選定理由、取り扱う内容と取り扱わない内容、対象読者などの説明。各言語固有の特性を把握できるようにするのが狙い。型付けモデル、プログラミングモデル、言語処理系、分岐構文と主要なデータ構造、言語固有の機能、など。
- 第 2 章「Ruby」
  - ダックタイピング、コードブロック、Mixin、オープンクラス、method_missing、メタプログラミング辺りが特徴的な機能として紹介されていた。並行処理に関する話はなかった。
  - Flavors って知らなかった / "このプログラミングスタイルはmixinと呼ばれ，Flavorsで初めて導入され，Smalltalk や Python など多くの言語で使われている．"
- 第 4 章「Prolog」
  - ルールを宣言的に記述し、それをユニファイして推論していく論理型言語。初めてまともにコードを読んだ。ルールを書くだけで制約充足問題を解けるのが不思議。ところどころ他の言語の面影を感じた。
  - 三日目は数独と 8 クイーンのソルバーの話で並行処理に関する話題はなし。
- 第 9 章「全体のまとめ」
  - 本書で紹介したプログラミングモデル、並行処理のための機能、筆者が特に気に入った特徴的な言語機能のまとめ。

# 感想

各言語の特徴がコンパクトにまとまっていて、当初の目的だった「並行並列処理機構についてざっくり理解する」を果たすことができた。Rust, Golang, Swift といった最近話題の言語でも是非書いてほしい。