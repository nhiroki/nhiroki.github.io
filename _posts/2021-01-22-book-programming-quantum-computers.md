---
layout: post
title: "読書｜動かして学ぶ量子コンピュータプログラミング"
date: 2021-01-22 00:00:00 +09:00
tags: book
image: /images/book-programming-quantum-computers.webp
---

『動かして学ぶ量子コンピュータプログラミング ― シミュレータとサンプルコートで理解する基本アルゴリズム』の読書メモです。

![表紙](/images/book-programming-quantum-computers.webp)

# 感想

- とても面白い本だった。量子コンピュータプログラミングは古典的なプログラミングと比べてパラダイムがあまりにも違いすぎて、脳の新しい領域が開拓されていく感じがしました。
- 本書の内容は、筆者らが開発・公開している [QCEngine](https://oreilly-qc.github.io) というオンライン量子計算シミュレータを使って試すことができます。環境構築せずにブラウザ上で手軽に実行できて良かった。
- 量子コンピュータのことを何も知らない人が最初にこの本を読むのは難しそう。いきなり「振幅の大きさの二乗が確率を表す」とか言われてもピンとこないだろうし。自分は『[驚異の量子コンピュータ](/2020/01/02/book-quantum-computer)』を先に読んでおいたのが役に立ちました。
- 訳者あとがきにある通り「急にギアを上げたような説明」がところどころ (特に後半) にあって読むのが大変でした。

# 読書メモ

[Twitter でのメモ書き](https://twitter.com/nhiroki_/status/1304430907269369856)

### 第 1 章　はじめに

- 本書のスコープ、シミュレータ QCEngine、QPU とその基本的な命令、シミュレータ・ハードウェアの限界 (キュビット数)、QPU プログラミングの特徴、など。
- 量子コンピュータが得意とするのは特定の問題領域であり、その観点から量子コンピュータはコプロセッサの一つとして捉えることができる。GPU や TPU などのように、このデバイスを QPU (Quantum Processing Unit) と呼ぶことで、それを明確にすることができる。

## 第 I 部　QPU プログラミング

### 第 2 章　単一キュビット

- フォトンと半透鏡によるキュビットの実装例、円表示、基本的な QPU 演算、ランダムなビット列の生成、通信路上の盗聴者を検知する簡単なコード例、など。
- 円表示
  - 塗りつぶされた同心円の半径を振幅の大きさとすることで、その面積 (半径の二乗に比例) が確率を表すんだね。よくできてる。
  - 相対位相は重ね合わせの大きさとは独立して変更可能。これは観測結果に大して直接的な影響を与えないことを意味する。しかしうまく使うことで間接的に影響を与えることができる。
  - qubit の状態は円表示で視覚化できるが、他にもブロッホ球によっても表現できる。円表示において ROTX 演算と ROTY 演算が PHASE (ROTZ) 演算ほど自明じゃないのは、それがブロッホ球上における作用に由来しているかららしい。
- ROOT-of-NOT 演算、じっくり追うと確かに「NOT 演算の平方根」って感じなんだけど、何かまだうまく腹落ちできてない。
- 章末の少し大きいプログラムを写経してみたんだけど、正しく写経できてるのか全然分からないな。確率的に動くので、何がどう動くのが正しい挙動なのか把握するのが難しい。生成されるビットをとりあえず固定して処理を追っていくと良い？ 
  - コードレビューとか大変そう。慣れの問題なのか、言語が洗練されれば良くなるのか？
- qubit はレジスタというよりは状態生成器みたく捉えると良いのかな？ランダムなビット列を生成してそれを READ で取り出すための装置？
- 例 2-4 の量子ランダムスパイハンターは HAD 演算を二回適用すると qubit の値が元に戻るのが重要なのか。送信者は HAD 演算の有無をランダムビットの生成で真にランダムに決めるので、盗聴者は盗聴したデータに対して HAD 演算を適用すべきかどうか分からない (もちろん偶然当たることもある)

### 第 3 章　多重キュビット

- 多重キュビットの円表示と回路表記、多重キュビットにおける単一キュビット演算、多重キュビット演算 (条件付き演算)、位相キックバック、スワップテスト、条件付き演算の構築方法、など
- 多重キュビットの状態を円表示で表す時、それぞれのキュビットの確率を個別に表示する (単一キュビット表現) のではなく、全キュビットをまとめて二進数表示したときに取りうる値それぞれの確率を表示する (複合キュビット表現)
- 例 3-1 はキュビット 1 が下位ビットを意味してるのか。逆だと思って混乱してた。キュビット 1 が 0 固定になるので取りうるビット列は ```000|0>, 010|2>, 100|4>, 110|6>``` となる。
- 図 3-5 が分かりにくかったけど、これは取りうるビット列を並べて、対象となるキュビットだけが反転した円の組 (演算対象ペア) について考えれば良いのか・・・？
  - ・・・という説明が隣のページに書いてあった。ちゃんと先まで読みましょう😅
- CNOT は control qubit の値に応じて NOT 演算を行う Controlled-NOT らしいけど、自分的には Conditional-NOT と呼んだ方が分かりやすいな。
- あー、演算を通して qubit グループの確率状態を変化させていく感じなんだな。
- 重ね合わせ状態にある qubit を control qubit とした条件付き演算を行うことがエンタングルメントの導入になるのか。理解した (本当？)
- CZ 演算 (CPHASE(180) 演算) の Z は PHASE 演算がブロッホ球上では ROTZ 演算と呼ばれるからかな？
- QCEngine に cphase() 命令があるつもりで書いてたんだけど動かず。ドキュメント読んだら phase() の第二引数で target qubits が指定できた。
- 入力値が異なる場合のスワップテストの結果が安定しないと思ったら、これって確実に同値性判定できるものじゃないのか。
  - qubits の値が同値の場合は絶対に 1 になるから複数回試行した結果一度でも 0 が出れば同値ではないことが分かる。一方、0 が出ない場合はどこかで試行を打ち切る必要があり、それは演算する人がどの程度同値性を信頼したいかによる。非破壊で同値性のテストができるの面白いな。
  - 見方を変えて 0 が出る回数をある程度許容すると、qubits 間の値の類似度のテストとも考えられる。なるほど。これは量子機械学習アプリケーションで有用だと考えられているらしい。
- 重ね合わせ状態の HAD 演算の結果をトレースするのがまだ難しい。

### 第 4 章　量子テレポーテーション

- IBM Quantum Experience を使った量子テレポーテーションのサンプルコード実行、Alice と Bob の二者間で量子テレポーテーションを行う回路図の解説。
- 実行ステップを追いかけるのがだいぶ難しくなってきた。
- テレポーテーションという用語は分かりにくい気がする。エンタングルメントすることで Alice と Bob の持つ qubit 間で確率状態を関連付けて、それから Alice 側で READ することでお互いの確率状態を収束させているだけだよね？なんかもっとふさわしい用語がありそうな気がする。
- Bob 側では受信した内容が重ね合わせの状態にあるので、送信内容を復元するには Alice 側で観測された結果を古典通信路で送ってもらい、それに応じた演算を適用する必要がある。量子テレポーテーションの説明でよく見る話だけど、処理ステップを追うことで何となく理解できてきた気がする。

## 第 II 部　QPU プリミティブ

- 重ね合わせ操作のためのプリミティブと位相操作のためのプリミティブに大別されるみたい。前者は並列性を用いた計算を可能にし、後者は結果の読み出しを確実にするものらしい。前者は何となくイメージが掴めてきたけど、後者はまだ良くわからん。
- 図 II-1「上位レベルから見た量子アプリケーションの構造」を常にイメージしておくのが重要そうな気がする。
  - 重ね合わせの生成 (アダマール演算) → 重ね合わせでの計算・位相操作 → 読み出し
- 量子コンピュータによる並列計算とは重ね合わせによる「状態空間の並列処理」なのに対し、古典的コンピュータによる並列計算は「データやタスクの並列処理」であり、「並列計算」と聞いた時にこの違いを理解してないと混乱するのかなぁ、と何となく思った。

### 第 5 章　量子算術演算と量子論理演算

- 演算に対する要件 (可逆性と複製不可能性)、基本演算 (inc/dec、足し算、負数、二乗)、量子条件付き実行、位相エンコード、スクラッチキュビットによる可逆演算、アンコンピュートによるスクラッチキュビットのリセット、量子論理ゲート、など。
- QPU 上での論理演算・算術演算の要件として可逆性と複製不可能性がある。複製不可能性はデータを読み出す (READ する) と qubit の状態が収束してしまうのが理由だと分かるけど、可逆性が必要とされる理由がよく分からない。p.87 には「量子力学の法則による」と書いてあるけど、どういうことなんだろう？
  - 量子コンピュータにおいて、論理・算術演算の可逆性は情報消去にかかる発熱 (情報消去の原理) をなくすためにあった方が良い性質で、それがなくても演算自体は実現できるという理解なんだけど、合ってる？

> QPU 上で任意の従来型回路を実現する最も単純な方法は、トフォリゲートのような可逆的な演算だけで従来型の等価回路を構築することです。そうすれば、量子レジスタの動きを仮想的にシミュレートすることができます。
>
> ― p.87

- READ を乱用すると従来型の計算になってしまうというのは何だか面白い。

> 量子コンピューティングにおける大きな課題の 1 つは、特定の計算を実行するために必要なスクラッチキュビットの数を減らすことです。
>
> ― p.106

- スクラッチキュビットをアンコンピュートするタイミングってそんなに自明じゃないと思うんだけど、これはプロダクション環境ではコンパイラが頑張ってアンコンピュートを挿入していく感じになるのかな？手作業で挿入していくのは厳しそう。

### 第 6 章　振幅増幅

- qubits の位相差は READ できないが、それを振幅の大きさに変換することで読み出せるようにする QPU プリミティブが振幅増幅。円表示では鏡で反射させるように操作することから鏡映演算とも呼ぶ。反復して演算することで、有標値を見つける確率が正弦波の形に変動する。

### 第 7 章　QFT：量子フーリエ変換

- QFT は量子レジスタに対する DFT。エンコードされた信号 (相対位相または振幅の大きさ) の周波数を取り出す。QFT は FFT に比べて（キュ）ビット数が増えると圧倒的に高速。
- 入力信号をどのように量子レジスタに載せるか、そしてどのように重ね合わせ状態にある結果を読み出すかが課題。逆 QFT をすることで周波数成分から信号を作り出すこともできる。

### 第 8 章　量子位相推定

- 各 QPU 演算は固有状態と固有位相を持つが、量子位相推定によってこの固有位相に関する情報を取り出せる。固有位相の推定精度は出力に使う量子レジスタのサイズに依存する。
- 固有位相は各 QPU 演算を特徴づける。また量子位相推定は重ね合わせ状態にある量子レジスタに対しても使える。このことから、任意の状態にある QPU レジスタが、どんな QPU 演算の固有状態の重ね合わせとして表現されているかが分かるっぽい。すごい。
- QRAM (Quantum Random Access Memory) について読んでる。QRAM は重ね合わせ状態にあるデータを読み書きする。内部的には従来どおりデータは非重ね合わせ状態で保存されているみたい。その代わりにメモリアドレスを重ね合わせ状態で与え、それらが指すデータ群を重ね合わせて読み出す感じ。
- このやり方だと重ね合わせの状態数だけメモリにアクセスする必要があるし、状態数分のメモリ空間を消費するよね？なかなか大変そう。これに対し、重ね合わせ状態にあるデータをそのまま保存するものは persistent quantum memory と呼ぶみたい。こちらの方が実現は難しい。

### 第 9 章　データの量子表現

- QPU レジスタへのデータエンコード方法を解説。小数 (固定小数点表現)、QRAM、ベクトル (状態エンコーディング・振幅エンコーディングと規格化)、行列 (振幅エンコーディング・量子シミュレーションによる等価な QPU 演算の探索)、など。
- ベクトル表現において、振幅エンコーディングは状態エンコーディングと比べて必要とするキュビット数が減るが、データを重ね合わせ状態でエンコードするため、読み出すのが難しい。
- 行列（正確にはエルミート行列）の表現は量子シミュレーションによってそれを表現する QPU 演算を求めるらしい。この QPU 演算はユニタリ行列で表現され、可逆性が保証される。データ表現のためにそれを生成する演算方法を求めるというのは面白いな。
- 昨年線形代数を復習したのが少し役立った。

## 第 III 部　QPU アプリケーション

### 第 10 章　量子探索

- 振幅の大きさを使った論理演算と位相論理演算の違い、位相論理演算を使った充足可能性問題の例、など。
- 今まで出てきた量子論理演算はその結果を振幅の大きさで出力していたのに対し、位相論理演算では結果が真となる入力値の位相を反転させることで出力する。反転された位相は振幅増幅の flip 回路として使うことで読み出せる。
- 位相論理演算は振幅の大きさを入力として位相を出力する。このため入力と出力がミスマッチするため直接連結できない。そこで、基本は振幅の大きさを使った論理演算で求め、最後の演算だけ位相論理演算を使ったりするみたい。
  - 最後だけわざわざ位相論理演算にする理由が分からなくなってきた。

### 第 11 章　量子スーパーサンプリング

- QPU の画像処理への応用を紹介した章。従来型のスーパーサンプリング (モンテカルロサンプリング) と比べて、量子スーパーサンプリングによる画像は特徴的で処理しやすいノイズのパターンが現れるらしい。
- 画像処理ということで他の例よりも分かりやすいかなと期待してたんだけど、読んでも全然頭に入ってこなかった・・・。

### 第 12 章　ショアの素因数分解アルゴリズム

- このアルゴリズムは、ある剰余計算の周期性を見つける部分と、それを元に素因数を見つける部分に分けられる。前者は QPU で実行し、後者は CPU で実行する。周期性を見つけるときには QFT を用いる。
- 難しくてだいぶ読み流してしまった。

### 第 13 章　量子機械学習

- QPU を使って連立線形方程式の計算、量子主成分分析、量子 SVM を実現する方法について。
- 本章の内容は私には難しすぎるので流し読みですませた。

## 第 IV 部　将来の展望

### 第 14 章　最先端を行く：文献案内

- 量子状態の表記方法、用語に関する補足、量子ゲートの分解 (量子コンパイル)、計算クラス、量子プログラミング言語などに関する簡潔な説明と参考文献のリストの紹介。